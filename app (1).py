"""
Personalized Learning Path Generator (Gradio app)

Features:
- Inputs: learning goal (text), current skill level, weekly available hours, target deadline (weeks)
- Outputs:
  - a human-friendly week-by-week curriculum with small daily tasks and milestones
  - a downloadable CSV schedule (week, day, task, est_minutes, resources)
  - built-in resource templates (placeholder links) and comments, no external APIs required

Deployment:
- To deploy on Hugging Face Spaces:
  1. Create a new Space (SDK: gradio, hardware: CPU).
  2. Add this file as app.py and add requirements.txt (provided).
  3. Push to the Space repo — HF will auto-run the Gradio app.

Author: Generated by GPT
Model: GPT-5 Thinking mini (info only)
"""

import math
import io
import tempfile
import csv
from datetime import datetime, timedelta
from typing import List, Dict, Tuple

import pandas as pd
import numpy as np
import gradio as gr

# ---------------------------
# Helper / Configuration
# ---------------------------

# Resource templates - placeholders the app will insert (no external API calls).
# You can replace "example.com" with real resources later.
RESOURCE_TEMPLATES = {
    "Intro Article": "https://example.com/article/{topic}",
    "Video Course": "https://example.com/video/{topic}",
    "Interactive Tutorial": "https://example.com/interactive/{topic}",
    "Project Repo": "https://example.com/repo/{topic}",
    "Documentation": "https://example.com/docs/{topic}",
    "Cheatsheet": "https://example.com/cheatsheet/{topic}"
}

# Mapping of skill level to pace modifier and recommended focus distribution
SKILL_CONFIG = {
    "Beginner": {
        "pace_modifier": 0.8,  # a bit slower per week
        "focus": {"foundations": 0.45, "concepts": 0.25, "practice": 0.15, "project": 0.10, "polish": 0.05}
    },
    "Intermediate": {
        "pace_modifier": 1.0,
        "focus": {"foundations": 0.20, "concepts": 0.30, "practice": 0.25, "project": 0.20, "polish": 0.05}
    },
    "Advanced": {
        "pace_modifier": 1.2,  # faster compression toward projects/advanced topics
        "focus": {"foundations": 0.05, "concepts": 0.25, "practice": 0.35, "project": 0.25, "polish": 0.10}
    }
}

MAX_WEEKS = 52
MIN_WEEKS = 1
MIN_HOURS = 0.5  # minimal reasonable weekly time

# For reproducible "variety" in generated tasks, we use numpy RNG (seeded by current time).
rng = np.random.default_rng(int(datetime.now().timestamp()) % (2**32 - 1))


# ---------------------------
# Core generation logic
# ---------------------------

def sanitize_inputs(goal: str, level: str, hours_per_week: float, weeks: int) -> Tuple[str, str, float, int]:
    """Validate and sanitize inputs; raise ValueError for invalid values."""
    goal = (goal or "").strip()
    if len(goal) == 0:
        raise ValueError("Please provide a learning goal (e.g., 'Learn Python for data analysis').")
    if level not in SKILL_CONFIG:
        raise ValueError(f"Unknown skill level: {level}")
    try:
        hours_per_week = float(hours_per_week)
    except Exception:
        raise ValueError("Weekly available hours must be a number.")
    if hours_per_week < MIN_HOURS:
        hours_per_week = MIN_HOURS
    try:
        weeks = int(weeks)
    except Exception:
        raise ValueError("Deadline (weeks) must be an integer.")
    weeks = max(MIN_WEEKS, min(MAX_WEEKS, weeks))
    return goal, level, hours_per_week, weeks


def build_topic_chunks(goal: str, weeks: int, focus: Dict[str, float]) -> List[Dict]:
    """
    Build week-level modules based on the goal and focus distribution.

    Returns a list with length == weeks, each entry is a dict with:
      - 'module_name', 'objectives', 'module_weight' (relative), 'suggested_topics' (list)
    """
    # A simple heuristic: create 5 high-level module buckets: foundations, concepts, practice, project, polish
    buckets = ["foundations", "concepts", "practice", "project", "polish"]
    bucket_weights = [focus[b] for b in buckets]

    # Convert to number of weeks per bucket proportional to weight * weeks (round with preserve total)
    raw = np.array(bucket_weights) * weeks
    # Use rounding with remainder allocation
    floored = np.floor(raw).astype(int)
    remainder = int(weeks - floored.sum())
    # allocate remainder to largest fractional parts
    fractions = raw - floored
    order = np.argsort(-fractions)
    for i in range(remainder):
        floored[order[i]] += 1

    # If still mismatch (rare), adjust
    if floored.sum() != weeks:
        # brute force adjust
        while floored.sum() < weeks:
            floored[np.argmax(fractions)] += 1
        while floored.sum() > weeks:
            floored[np.argmin(fractions)] -= 1

    # Build modules per week
    modules = []
    chunk_topic_base = generate_topic_breakdown(goal)
    pointer = 0
    for bname, weeks_in_bucket in zip(buckets, floored):
        for i in range(weeks_in_bucket):
            # select suggested topics from topic base with some variety
            topics = select_topics_for_bucket(chunk_topic_base, bname, pointer, weeks_in_bucket, goal)
            module = {
                "bucket": bname,
                "module_name": make_module_name(bname, pointer + 1),
                "objectives": make_objectives(bname, goal),
                "suggested_topics": topics
            }
            modules.append(module)
            pointer += 1
    # If modules list differs from weeks (shouldn't), pad with practice
    if len(modules) < weeks:
        for _ in range(weeks - len(modules)):
            modules.append({
                "bucket": "practice",
                "module_name": "Practice & Reinforcement",
                "objectives": ["Consolidate knowledge with exercises", "Short practice tasks"],
                "suggested_topics": [goal]
            })
    # Trim if longer
    modules = modules[:weeks]
    return modules


def generate_topic_breakdown(goal: str) -> Dict[str, List[str]]:
    """
    Naive keyword-based topic breakdown.
    This is intentionally simple: it creates plausible subtopics by splitting the goal's words.
    Replace or expand later with curated topics.
    """
    words = [w.strip(" ,.-").lower() for w in goal.split()]
    base = " ".join(words[:3]) if words else goal
    # create templates
    return {
        "foundations": [f"core concepts of {base}", "essential terminology", "basic tools and setup"],
        "concepts": [f"{base} fundamentals deep-dive", "key techniques and patterns", "theoretical background"],
        "practice": [f"small exercises in {base}", "katas and short problems", "automated practice tasks"],
        "project": [f"mini project: {base} app", "build a portfolio item", "case-study based project"],
        "polish": [f"refine portfolio and resume", "read best-practices", "final presentation/README"]
    }


def select_topics_for_bucket(topic_breakdown: Dict[str, List[str]], bucket: str, idx: int, bucket_size: int, goal: str) -> List[str]:
    """Return 1-3 suggested topics for the module week."""
    candidates = topic_breakdown.get(bucket, [goal])
    # rotate through to give variety
    chosen = []
    # pick one guaranteed
    chosen.append(candidates[idx % len(candidates)])
    # possibly add up to 2 more variants
    if len(candidates) > 1:
        extra = rng.choice(candidates, size=min(2, len(candidates)), replace=False).tolist()
        for e in extra:
            if e not in chosen:
                chosen.append(e)
    return chosen[:3]


def make_module_name(bucket: str, num: int) -> str:
    names = {
        "foundations": f"Week {num}: Foundations & Setup",
        "concepts": f"Week {num}: Core Concepts",
        "practice": f"Week {num}: Focused Practice",
        "project": f"Week {num}: Project Work",
        "polish": f"Week {num}: Polish & Portfolio"
    }
    return names.get(bucket, f"Week {num}: Study")

def make_objectives(bucket: str, goal: str) -> List[str]:
    base = goal
    mapping = {
        "foundations": [f"Understand the basic terminology of {base}", "Install and configure essential tools", "Complete a simple hello-world exercise"],
        "concepts": [f"Learn key techniques relevant to {base}", "Read short conceptual articles or watch explainers", "Summarize main tradeoffs"],
        "practice": [f"Complete small focused exercises about {base}", "Work up to 30-60 minute practice sessions", "Automate checking when possible"],
        "project": [f"Start and progressively build a small project demonstrating {base}", "Apply earlier learning in realistic context", "Prepare code for review"],
        "polish": [f"Prepare portfolio artifacts for {base}", "Document learnings and write README", "Create short demo or presentation"]
    }
    return mapping.get(bucket, [f"Work on {base}"])


def estimate_task_times(hours_per_week: float, days_per_week: int = 7, intensity: float = 1.0) -> float:
    """
    Return an estimated minutes-per-day budget given weekly hours and an intensity modifier.
    intensity can be used to scale for skill level.
    """
    total_minutes = max(1, hours_per_week * 60 * intensity)
    per_day = total_minutes / days_per_week
    return per_day


def create_daily_tasks_for_week(module: Dict, week_index: int, hours_per_week: float, level_modifier: float) -> List[Dict]:
    """
    For a given module (week), create up to 7 daily tasks with estimated minutes and resource placeholders.
    Returns list of dicts: {week, day, task, est_minutes, resources}
    """
    days = []
    per_day_budget = estimate_task_times(hours_per_week, days_per_week=7, intensity=level_modifier)
    # Choose 1-3 tasks per day depending on budget
    # Smaller budgets -> 1 micro-task per day; larger budgets -> 2-3 tasks
    tasks_per_day = 1
    if per_day_budget >= 60:
        tasks_per_day = 2
    if per_day_budget >= 150:
        tasks_per_day = 3

    # Generate a pool of "atomic" task templates for variation
    atomics = [
        "Read: {topic} (short article)",
        "Watch: {topic} (10-30 min video)",
        "Try: interactive exercise on {topic}",
        "Implement: small code snippet for {topic}",
        "Quiz: quick self-test on {topic}",
        "Refactor: improve previous code / notes on {topic}",
        "Write: short summary (5-10 min) of {topic}",
        "Project: add one feature to your project related to {topic}"
    ]

    topics = module.get("suggested_topics", [])
    bucket = module.get("bucket", "practice")
    # For each day:
    for d in range(1, 8):
        # pick tasks_per_day atomic tasks (no repeats)
        chosen = rng.choice(atomics, size=tasks_per_day, replace=False).tolist()
        # assign minutes split across tasks roughly equal to per_day_budget
        minutes_each = max(5, int(per_day_budget / tasks_per_day))
        for task_template in chosen:
            topic = rng.choice(topics) if topics else module.get("module_name")
            task_text = task_template.format(topic=topic)
            resources = generate_resources_for_task(topic, bucket)
            days.append({
                "week": week_index + 1,
                "day": d,
                "task": task_text,
                "est_minutes": minutes_each,
                "resources": "; ".join(resources)
            })
    return days


def generate_resources_for_task(topic: str, bucket: str) -> List[str]:
    """Return a short list (1-3) of resource placeholders using RESOURCE_TEMPLATES."""
    keys = list(RESOURCE_TEMPLATES.keys())
    # pick 1-3 resources; ensure "Project Repo" appears for 'project' weeks
    chosen = []
    if bucket == "project":
        chosen.append(RESOURCE_TEMPLATES["Project Repo"].format(topic=topic.replace(" ", "-")))
    # randomly choose other templates
    k = min(2, max(1, rng.integers(1, 3)))
    rest = rng.choice(keys, size=k, replace=False).tolist()
    for r in rest:
        # avoid duplicating project repo in list if already added
        if r == "Project Repo" and RESOURCE_TEMPLATES["Project Repo"].format(topic=topic) in chosen:
            continue
        chosen.append(RESOURCE_TEMPLATES[r].format(topic=topic.replace(" ", "-")))
    return chosen


def generate_milestones(modules: List[Dict]) -> List[str]:
    """Create estimated milestones at key weeks (every ~quarter of total weeks)."""
    n = len(modules)
    milestone_weeks = sorted({1, math.ceil(n / 3), math.ceil(2 * n / 3), n})
    milestones = []
    for w in milestone_weeks:
        mod = modules[w - 1]
        milestones.append(f"Week {w}: Complete '{mod['module_name']}' — objectives: {', '.join(mod['objectives'][:2])}")
    return milestones


def build_schedule_dataframe(all_days: List[Dict]) -> pd.DataFrame:
    """Return a pandas DataFrame sorted by week and day."""
    df = pd.DataFrame(all_days)
    df = df.sort_values(["week", "day"]).reset_index(drop=True)
    # create friendly date-like column (week/day)
    df["week_day"] = df["week"].astype(str) + " - Day " + df["day"].astype(str)
    # reorder columns
    df = df[["week", "day", "week_day", "task", "est_minutes", "resources"]]
    return df


# ---------------------------
# Public-facing function used by Gradio
# ---------------------------

def generate_learning_path(goal: str, skill_level: str, weekly_hours: float, deadline_weeks: int, include_dates: bool = False, start_date: str = None) -> Tuple[str, str, str]:
    """
    Main orchestrator: returns (human_readable_plan_markdown, csv_file_path, df_as_string_preview)
    - csv_file_path is a path that Gradio can return for download.
    """
    try:
        goal, skill_level, weekly_hours, deadline_weeks = sanitize_inputs(goal, skill_level, weekly_hours, deadline_weeks)
    except ValueError as e:
        return f"Error: {str(e)}", None, ""

    cfg = SKILL_CONFIG[skill_level]
    pace_modifier = cfg["pace_modifier"]
    focus = cfg["focus"]

    # Build modules by week
    modules = build_topic_chunks(goal, deadline_weeks, focus)

    # For each week, create daily tasks
    all_days = []
    for wi, mod in enumerate(modules):
        # level modifier tweaks per skill level (beginner -> slower intensity)
        level_modifier = pace_modifier
        days = create_daily_tasks_for_week(mod, wi, weekly_hours, level_modifier)
        # For each day, if include_dates is True, compute actual calendar date from start_date
        all_days.extend(days)

    # Build DataFrame
    df = build_schedule_dataframe(all_days)

    # Add date column optionally
    if include_dates:
        # parse start_date or use today
        try:
            base = datetime.strptime(start_date, "%Y-%m-%d") if start_date else datetime.today()
        except Exception:
            base = datetime.today()
        # compute date for each row: week and day -> base + (week-1)*7 + (day-1)
        df["date"] = df.apply(lambda r: (base + timedelta(days=((int(r["week"]) - 1) * 7 + (int(r["day"]) - 1)))).strftime("%Y-%m-%d"), axis=1)
        # reorder columns
        df = df[["week", "day", "date", "week_day", "task", "est_minutes", "resources"]]

    # Create milestones and human readable plan
    milestones = generate_milestones(modules)

    # Create readable markdown plan
    plan_lines = []
    plan_lines.append(f"# Learning Path: {goal}")
    plan_lines.append(f"- Skill level: **{skill_level}**")
    plan_lines.append(f"- Weekly hours available: **{weekly_hours} hours/week**")
    plan_lines.append(f"- Deadline: **{deadline_weeks} weeks**")
    plan_lines.append(f"- Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    plan_lines.append("")
    plan_lines.append("## Estimated milestones")
    for m in milestones:
        plan_lines.append(f"- {m}")
    plan_lines.append("")
    plan_lines.append("## Week-by-week summary")
    for i, mod in enumerate(modules):
        plan_lines.append(f"### Week {i+1} — {mod['module_name']}")
        plan_lines.append(f"**Objectives:** {', '.join(mod['objectives'])}")
        plan_lines.append(f"**Focus topics:** {', '.join(mod['suggested_topics'])}")
        plan_lines.append("**Sample daily tasks:**")
        # show up to first 3 tasks for sample
        sample_tasks = [t["task"] for t in all_days if t["week"] == i+1][:3]
        for st in sample_tasks:
            plan_lines.append(f"- {st}")
        plan_lines.append("")  # blank line

    plan_markdown = "\n".join(plan_lines)

    # Save dataframe to a temporary CSV file for download
    tmp = tempfile.NamedTemporaryFile(mode="w", suffix=".csv", delete=False, newline="", encoding="utf-8")
    df.to_csv(tmp.name, index=False)
    tmp.close()
    csv_path = tmp.name

    # Also create a small string preview (first 20 rows) for quick display
    preview = df.head(20).to_string(index=False)

    return plan_markdown, csv_path, preview


# ---------------------------
# Gradio UI
# ---------------------------

def build_demo():
    with gr.Blocks(title="Personalized Learning Path Generator") as demo:
        gr.Markdown(
            """
            # Personalized Learning Path Generator
            Enter your learning goal, current skill level, weekly availability and deadline.
            The app will produce a week-by-week curriculum, small daily tasks, resource placeholders, milestones, and a downloadable CSV schedule.
            """
        )

        with gr.Row():
            with gr.Column(scale=2):
                goal_input = gr.Textbox(label="Learning goal", placeholder="e.g., 'Learn Python for data analysis'", lines=2)
                level_input = gr.Radio(choices=["Beginner", "Intermediate", "Advanced"], label="Current skill level", value="Beginner")
                hours_input = gr.Number(label="Weekly available hours", value=5, precision=1)
                weeks_input = gr.Slider(minimum=1, maximum=52, step=1, label="Target deadline (weeks)", value=8)
                include_dates = gr.Checkbox(label="Include calendar dates in CSV (optional)", value=False)
                start_date = gr.Textbox(label="Start date (YYYY-MM-DD, optional)", placeholder="Leave blank to start today")
                generate_btn = gr.Button("Generate learning path", variant="primary")
                # Helper tips
                gr.Markdown(
                    """
                    **Notes & tips**
                    - This tool uses built-in resource templates (placeholder links). Replace with real links when ready.
                    - For short deadlines, expect compressed modules and more project-focused work.
                    - Adjust weekly hours realistically — consistency beats cramming.
                    """
                )

            with gr.Column(scale=3):
                output_markdown = gr.Markdown("", elem_id="plan_markdown")
                with gr.Row():
                    csv_file = gr.File(label="Download schedule CSV", visible=False)
                    preview_box = gr.Textbox(label="Schedule preview (first 20 rows)", lines=15)

        # Action
        def on_generate(goal, level, hours, weeks, incl_dates, st_date):
            try:
                md, csv_path, preview = generate_learning_path(goal, level, hours, weeks, include_dates=incl_dates, start_date=st_date)
                # make the file visible for download
                return md, gr.File.update(value=csv_path, visible=True), preview
            except Exception as e:
                return f"Error: {str(e)}", gr.File.update(visible=False), ""

        generate_btn.click(
            on_generate,
            inputs=[goal_input, level_input, hours_input, weeks_input, include_dates, start_date],
            outputs=[output_markdown, csv_file, preview_box]
        )

        # Footer
        gr.Markdown(
            """
            ---  
            **Export & deployment**: This app is self-contained. To deploy on Hugging Face Spaces, include `app.py` and `requirements.txt` in the repo.
            """
        )
    return demo


if __name__ == "__main__":
    demo = build_demo()
    demo.launch(server_name="0.0.0.0", server_port=7860, share=False)
